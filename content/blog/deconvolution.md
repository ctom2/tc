---
title: "Iterative image deconvolution"
date: 2022-06-02T15:31:00+02:00
draft: false
---

One of the most prevalent tasks in computer vision is deblurring and image deconvolution. Algorithms capable of recovering a clear representation from a blurry image can be applied to photos captured with mobile phones' cameras as well as professional imaging systems such as [microscopes](https://www.nature.com/articles/s41587-021-01092-2) or [telescopes](https://astrodoc.ca/wp-content/uploads/2017/06/Sky-and-Telescope-July-2017-Deconvolution-article.pdf). 

Mathematically, the image degradation can be denoted as follows. 

```
y = x * k + n
```

The blurred image `y` is formed by first convolving the sharp representation `x` with some kernel `k` and then adding noise `n` (e.g., coming from dust on the optics or measurement errors). Both the image and the kernel can be thought of as value matrices. Each pixel in the convolved image is obtained through element-wise multiplication of the corresponding pixel in the input image and its neighboring pixels with the kernel. The final convolved image is produced by applying the kernel to each pixel in the input image.

![Convolution](/convolution.png)

With the knowledge of the convolved image and the corresponding kernel, we can reverse the convolution and obtain a representation of the input image. This process is called [deconvolution](https://reader.elsevier.com/reader/sd/pii/S1046202316305096?token=F8F547C2064FC88FAB3466F42581E4E07C091B6DBF4177B5717DA2B3B53A29D5E8F3A3CFF945F42208A03BF043E78D1A&originRegion=eu-west-1&originCreation=20220602154212).

For microscopes, for example, the kernel quantifies the light spread caused by defocusing or motion. Consider a pixel-sized light bead on a dark background. When the microscope is focused, the bead will resemble a pixel. When the microscope defocuses, however, the aberration spreads the light over a greater area with reduced intensity (the overall amount of light will be the same, but distributed over a larger area). In real-world scenarios, such as [fluorescent microscopy](https://t-c.me/deconvolution/#:~:text=fluorescent%20microscopy), the blur produced by out-of-focus equipment must be corrected and, ideally, reversed before the images can be effectively evaluated. Deblurring algorithms are typically classified as **blind** or **non-blind** based on whether or not the kernel causing the blur is known.

While the [Richardson-Lucy](https://opg.optica.org/josa/abstract.cfm?uri=josa-62-1-55) [method](https://ui.adsabs.harvard.edu/abs/1974AJ.....79..745L/abstract), a maximum-likelihood approach, is one of the most frequently applied non-blind deconvolution algorithms, we will focus on an even simpler method, the [Landweber iteration](https://www.jstor.org/stable/2372313).

The Landweber method is a non-blind approach for minimising the L2 norm of the residual between the input blurred image `y` and the predicted sharp representation `x'` blurred with the known kernel `k` iteratively. While we can extract x in the frequency domain from the convolution equation above, the process is prone to producing noisy results. As a consequence, Landweber uses [gradient descent](https://ml-cheatsheet.readthedocs.io/en/latest/gradient_descent.html) to converge to the best solution possible. The algorithm is described in the pseudocode below.

```
function estimate_x(x_old, y, k):
    lambda = 0.7
	
    term_1 = lambda * transpose(k)
    term_2 = y - k * x_old
    
    return x_old + term_1 * term_2
    

function landweber(y, k):
    # make initial estimate as randomly initalised matrix 
    x = noise()

    for i = 1 to 10:
        x = estimate_x(x, y, k)
        
    return x
```

The objective of the algorithm is to constantly enhance the estimate so that it appears as sharp as possible. The algorithm must therefore work with initial estimation, which is often generated by randomly initializing a matrix with Gaussian noise, or just by using the blurred image. The approximated image is then improved with each iteration.

The number of iterations is a key component in the Landweber algorithm. Keeping the number low will cause the method to fail to reconstruct fine features, whereas increasing the number will enhance the noise in the image and add the [ringing effect](https://www.researchgate.net/publication/320544148_Explicit_Ringing_Removal_in_Image_Deblurring). Because the optimal number depends on the size of the image, the amount of noise in the image, and the type of visual structures, it is usually necessary to run the algorithm numerous times with different settings.

The Landweber iteration is implemented in Python using `torch` in the code below. Instead of being initialized as a matrix with Gaussian noise, the first estimate is set as the input blurred image.

```
import torch

def lw(k0, y0, i=10):

    lam = 0.8
    kdim = k0.shape[-1]
    
    x0 = y0

    for _ in range(i):

        temp_x = torch.conv2d(x0, k0, stride=1, padding=kdim//2)
        temp_x = y0 - temp_x
        temp_x = torch.conv2d(
            temp_x, 
            torch.flip(k0, [0, 1, 2, 3]), 
            stride=1, 
            padding=kdim//2
        )

        x0 = x0 + lam * temp_x
        
    return x0
```

The algorithm can be used to enhance the sharpness and contrast of blurry images like the one below, that shows the blurred image, the image deconvolved with the Landweber method, and the ground truth sharp image, respectively.

![Deconvolution](/milky.png)

